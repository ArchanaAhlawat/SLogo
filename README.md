**SLogo**
=======
Simple Logo (SLogo) implementation adapted from Logo, a simple educational programming language, using turtles for animations. This program provides a user-friendly IDE that allows users to input commands to move a turtle, create new turtles, write loops, create functions, perform basic calculations, and other similar functions. The results of these commands are shown directly on the UI. Goals of this project are interpretability, ease-of-use, and flexibility. Functions can be created using any combination of basic building-block commands. Furthermore, new commands can be created on the back-end easily. Further information on the code design is below.

**Design Review**
=======

### **Overall Design**
#### Front End
At a high-level, the front end is powered by the FrontEndDriver, and the rest of the classes in the front end package are used in the Front End Driver to add different functionality on the user-facing screen as well as trigger reactions after the user has taken some actions such as clicking or submitting a new command.  The FrontEndDriver creates the general user view workspace, and utilizes classes like History or Background picker to allow a user to see the history of commands on the screen and choose a background color.  In addition to helper classes that define specific sections of the user view, the front end also contains functionality to perform user actions such as saving history (SaveDriver, SaveUI) or changing/choosing the language of commands (LanguageChooser), and interpret backend data that is passed (DisplayTurtleManager, DisplayTurtle).  

The front end interfaces with the back end via the Controller class, which implements the ControllerAPI interface.  Controller has methods that the front end directly uses to pass information to the back end and obtain updated values from it as well.  Broadly, it has methods to activate and reactivate turtles, create a new collection of turtles (for new screens), pass commands to the back end parser and obtain return values, obtain new turtle information, and get user defined command or variable information.  The Controller and the front end rely on the back end for throwing errors properly, and the front end catches them and displays a message to the user.  Front end also really relies on the information from backend to be in the right format -- such as a double return value and properly defined turtles with all characteristics needed.

#### Back end
The back end is connected to the front end via the back end Driver class, which is called by Controller when the front end passes information or obtains information from back end.  The back end Driver basically has all the same functionality as Controller, but it directly interacts with specific back end classes such as Parser.

The Parser is the main class in the back end after the Driver.  The parser basically takes in a string command and goes through it, storing data in a Stacks object, and then calling commands using Java Reflection.  All the commands are in separate classes that implement different interfaces, and turtles are updates within them.  Each command class takes in the current Stacks object to use the data that has been stored and record new, updated values.  Parser then records the double return value based on the Stacks object.  

The back end uses language properties files in LangMaps in order to construct language maps to provide localization functionality.

Finally, the next big part of the back end is the TurtleTree interface, which implements the composite design pattern via Turtle and TurtleManager.  Basically, the TurtleTree API provides methods that are common to both Turtle and TurtleManager (although this was not necessarily implemented correctly -- see design weaknesses section), so that commands could use either a single turtle or a collection of turtles to operate on and update.  TurtleManager includes additional methods to update a collection of turtles, such as adding turtles, deactivating turtles, activating turtles, and finding the total number of turtles. 

#### How to add new functionality
##### New Commands
To add a new command, a new class needs to be made in the package that corresponds to the type of command it is (ex: multiple turtle commands, boolean commands, etc.).  If the package does not exist yet, then the package location would need to be added to the map in parser (this is a design flaw: adding a new location in an XML file would be better).  Then this new command class must implement a commands interface.  The programmer can add a new interface if they want, or they can just extend GeneralCommands.  Then a new constructor will be automatically defined that calls the superclass constructor.  The programmer must fill in the body of the execute(Stacks instructionStacks, TurtleTree currentTurtle) method with whatever the command does.  If this new command uses multiple lists, variables, commands, etc. like the previously defined commands do, then this body will easily be filled in with existing functionality in the Stacks class (which has recorded all the data needed).  Of course, parsing through commands will need to be updated if this new command is radically different from the way other commands have been organized.  Finally, if the new command updates turtle characteristics, then it will need to call currentTurtle and use the appropriate methods.  If an additional characteristic of a turtle must be added, then the programmer must add methods in the TurtleTree interface and its implemented classes, Turtle and TurtleManager.  Other than this, nothing else must be changed.  The new command should run.  Basically, adding a new command is pretty easy unless it radically departs from existing command norms.

##### New Component in Front End
Adding a new component in the front end would require a programmer to add a new class and create their desired element, and then create a new line(s) of code in the FrontEndDriver to add the element to the screen where they want.  If this new component requires information from the backend, then it will need to use Controller methods to get that information.  If those methods do not exist yet, then the programmer will need to add that method in the Controller (as well as the Controller API), in the back end Driver, and connect the new back end Driver method to whatever information is needed in the back end. 

##### Adding an Unimplemented Specification
Grouping: Adding grouping functionality shouldn't be very hard at all with the way that the parsing is implemented currently.  The only thing that would need to be changed are the commands that can use grouping functionality.  Currently, commands like Sum use a Stacks object to get two doubles and add them (or do whatever action to them).  Instead, this would change to continue getting doubles from the Stacks object until there are no more doubles present. So within each command, a loop would need to be added where the if statement is when the stack is not empty.  However, this is repeated code, so the commands interface that applies to these grouping commands would could implement that loop instead.  These are minimal code changes.

Are the dependencies between the parts clear and easy to find (e.g., public methods and parameters) or do they exist through "back channels" (e.g., static calls, order of method call, sub-class type requirements)?

#### Dependencies
I think that the dependencies are pretty easy to find.  There are mostly no unnecessary static calls or classes.  Parameters are always superclass type.  Public methods and interfaces provide all the information and actions needed, and there is absolutely no direct communication between backend and frontend.  

### Two components that I did not implement
1) One component that I didn't implement is the singular Turtle class and all the functionality that a turtle can have.  It is very readable because all the method names make it clear what the method does such as: xDisplacement, distance, angle, getAbsoluteOrientation, etc.  These methods do exactly what they sound like they do.  Also, most of these methods are very short.  It is encapsulated because all possible computation is implemented in each method but the results seen are mostly just doubles.  So the implementation details are totally hidden from anyone that uses this class.  Also, there are many void methods that do things like move a turtle and all one has to do to trigger this is call turtle.move().  How a turtle actually moves is hidden from the user.

2) Another component that I did not implement is the design of the commands classes.  All commands classes are separated into different packages that reflect the broad actions they perform.  Then, since various commands share certain functionality, repeated code was eliminated by creating different superclasses for these similar commands.  These superclasses are very readable because they have simple, short, and clear methods like toUpdate() and constants that need to be used often.  The logic is general and applicable to many different commands classes.  These superclasses encapsulate commands functionality effectively because specific things like performing certain intermediate calculations or obtaining a number of doubles or strings from the Stacks object are done in the superclasses rather than the concrete commands subclasses.  Therefore, the subclasses just use information and functionality inherited from the superclass without changing this every time or needing to.

Overall, I learned about the importance of adding good, clear javadoc comments WHILE writing code and not just at the end and how to effectively add superclasses and identify repeated code in several areas.
Is the total code generally consistent in its layout, naming conventions and descriptiveness, and style? Give specific examples for or against by comparing code from different team members

#### Consistency
Generally, our code is pretty consistent.  However, there are some issues.  First of all, we don't always use _my_ before the names of specific objects.  Also, there are some classes in the front end that have excessive spaces that identifies its writer because it's so different from all the other pieces of code.  Otherwise, our javadoc comments are fairly descriptive at the same level.


### My Design
#### High Level Overview
The Parser sets the language of commands based on user selection, parses through instructions (obtained via back end Driver), using an instance of the Stacks class to store data such as user defined variables, lists, and just normal double numbers.  The Parser also contains the current TurtleTree object, that holds all possible turtles (or only 1).  Then, when a command is identified, Reflection is used to create an object of the concrete command class that is needed, and then the execute method of that concrete command class is run.  This execute method uses the Stacks object and the TurtleTree concrete object to perform the particular command.  The TurtleTree concrete object is always a TurtleManager, even if contains only one turtle.  Stored information in Stacks is used by pushing the appropriate item off a stack.  Each command class updates the double stack in the Stacks class and then the Parser obtains the new double that is the return value.

I also implemented the "complex" commands from the basic implementation sprint.  These include DoTimes, For, If, IfElse, MakeUserInstruction, MakeVariable, Repeat, and my helper command class I created, ProcessUserInstruction.  These classes mostly use CommandLists obtained from the Stacks instance, create a new temporary Parser to handle all intermediate calculations, and process through all the elements in these lists.  They also have more interaction with outside classes (via methods from the Parser class) than the simpler methods.  For example, MakeVariable and MakeUserInstruction update UserVariables and UserCommands by using methods in Parser.

I implemented all the multiple turtle commands: Ask, AskWith, ID, Tell, and Turtles.  These commands generally also rely on CommandLists obtained from the given Stacks instance, and then process different actions on given turtles by calling other methods already defined.

I implemented the composite design pattern for turtles.  I created the interface TurtleTree, edited Kelly's Turtle class to have it implement this interface and added methods, and also created the TurtleManager concrete class that handled multiple Turtles.  The TurtleManager has added functionality to handle lists of turtles, active and inactive.  It is used within all the commands methods (if needed) and reactivate and deactivate methods can be triggered by front end --> controller --> back end driver.

#### Two Features I Implemented
* Stacks Class
	* I think that the using multiple stacks in order to hold information from commands until they are needed for computation was a very good idea.  At first, I used one stack that I created locally within the Parser class, and this stack contained doubles.  However, when I realized I would need to be able to handle different types of information like a list of commands or list of variables, I knew that new stacks had to be added.  That would have been confusing to implement within the Parser class itself, so I decided to abstract that functionality out to a separate class.  
	* My reasoning for using stacks to deal with all these elements was that I could properly maintain a certain ordering of elements and pop them off as I needed within the commands.  This idea stemmed from thinking of the commands like math operations, where the innermost computation must be done first, then the result of that is used for the computation directly outside of that one, and on and on.
	* The huge benefit of abstracting out stacks is that the Parser can simply identify that an element needs to be added to a stack to be stored, and then push that element in by using the push(String element) method.  The Parser does not need parse further and use regex to figure out whether this particular element is a double or a variable.  The Stacks class can handle this by using regex and identifying what particular inner stack the given element should be added to.  Similarly, removing elements from stacks can be abstracted in this way.
	* Assumptions or Dependencies: 
		* Some parsing and regex use needs to be in the Parser class in order to identify whether or not a given element should be added to a stack or not.  So there is an assumption that this immediate parsing works. The stacks class slightly mitigates this by only adding an element to a stack if it fits the regex for the stack (like double or variable or command).
		* One slight thing that could be improved is that the Stacks class may have become a bit of a god class, holding a lot of relevant, important data about the specific set of commands that were passed through.  For example, it contains information about user variables and user commands by holding references to these classes.

* AskWith Class (and kind of Ask)
	* This code needs improvement because the execute method is pretty long and not very readable.  This class, along with some of the other multiple turtle methods, does not take advantage of an appropriately specific interface.  They instead extend GeneralCommands.  The code for Ask and AskWith is similar and repeated code could be extracted out into an interface MultipleTurtleCommands.  This would both serve encapsulation purposes because certain operations would be slightly hidden, and also eliminate repeated code.
	* Another needed improvement is making "Tell [ " a constant in the interface so that I can use it to call the Tell command and not hardcode that in.  This is a simple fix that would make the code much better.
	* Otherwise, the design of the actual code inside this class is similar to other classes.  The given Stacks object is used to access certain relevant information, such as the conditions for turtles and the given commands.  Then, a temporary parser object is created to run through these intermediate calculations, and finally add the double return value to the current stacks object at the end.
	* Assumptions or Dependencies: Assumption that the stacks class and the parser class have properly identified and stored the data needed.  It not, this command will not work.  Errors in this class are thrown to Parser, which throws ultimately to the frontend.


### Flexibilty
#### What makes this design flexible or not
* Adding commands is a pretty simple process, as explained above.  This is definitely very important for ensuring this program can implement a lot of different and useful commands.
* Adding new syntax into commands would be a bit more complicated than adding a new command, but it would still just involve adding another stack or list to the Stacks class, adding a line to the push() method that abstracts the type of the element out, and using the method in a command class as needed.
* The composite design pattern used to handle one turtle or multiple turtles was very helpful.  I am not quite sure if I've implemented it as it is meant to be implemented, but it made writing commands pretty easy and I didn't have to change that much to go from commands working for one turtle to multiple, so that indicates that the design simplified things effectively.  Adding more commands or characteristics to turtles would be easy to do.
* An inflexible area of improvement: The front end has a separate DisplayTurtle class that holds similar information as the backend Turtle class, and when information about turtles is passed to the front end, DisplayTurtleManager basically uses information from each Turtle object (encapsulated with an Updates class that only allows front end to access certain Turtle characteristics that it needs and nothing more) to create and update turtles in its own list of front end DisplayTurtles.  This is a slightly convoluted design and involves some repeated code from backend to frontend.  It would be better to keep only one type of turtle class and then translate information to front end differently.

#### Two features that I did not implement
* Handling multiple turtles' information between front end and back end with the Updates class
	* As mentioned briefly before, the Updates class is used to only allow front end access to the information it needs from each back end turtle and not any more than that. 
	* I think this code is interesting because it transforms a backend object that has a lot of information and actions (methods) associated with it into something that is kind of like a static, temporary object for front end to basically read information from.
	* The backend Turtle is necessary to run with Updates.  Then, the DisplayTurtleManager class in the front end is what actually calls Updates on each given turtle.
	* The Updates class itself is pretty simple.  Its constructor takes in a TurtleTree object (will always end up being a Turtle as it is implemented in the front end now).  Then, many instance variables are set by calling methods from the TurtleTree object.  There are many getter methods that allow DisplayTurtleManager to actually access this information.  The DisplayTurtleManager class iterates through the list of active Turtles it gets from FrontEndDriver (which gets this list from controller --> back end driver --> parser), creates a new Updates object using the specific Turtle as an argument, and then uses this new Updates object to assign the variables of the turtle to the associated DisplayTurtle objects.
	* It is clear as to how to extend this design to add more characteristics to the Turtle because you can just add them to the Turtle class in the back end, then add them to the Updates class along with a getter method, and then add that same characteristics in the DisplayTurtle class.  
	* However, this design is convoluted for reasons I mentioned previously.  Also, it is inefficient because of the repeated call to create new Updates objects even if the Turtle hasn't been newly created.  
	* It is definitely good to limit the front end's access to all turtle commands by using Updates, but it might be better to transform turtles into Updates objects (static versions basically) within the backend and then just pass those static versions with limited capabilities to the front end.  In this way, the Turtle class implementation would actually be completely encapsulated.
	
* Reactivating and deactivating turtles by clicking on turtles
	* I think this is interesting because it requires the front end to trigger a change in the back end and pass some new information back rather than the traditional other way around.  Reactivation and deactivation must be able to change the current active turtles list in the backend.
	* Reactivation and deactivation take place in the FrontEndDriver. Here, there are checks to see when a user clicks on a turtle, which changes a turtles characteristics.  There is a listener that triggers back end changes when it detects that there has been a change in the turtle's activity status (using a boolean).  When a changes has been detected, the Controller method deactivate(id) or reactivate(id) are called, which call their respective methods in the back end Driver, which directly impacts the list of active turtles by updated the TurtleTree object that is stored and instantiated in Driver.   The id parameter is the turtle ID.  It is needed to identify exactly what turtle must be de- or reactivated.  TurtleTree has methods reactivate(id) and deactivate(id) that update the active turtles list (implemented and used in TurtleManager).
	* Actually updating the active turtles list is very much encapsulated in the TurtleManager.  The implementation details of what type of collection of objects this "list" is and how objects will be added and removed is left to TurtleManager.  The front end only has access to active turtles, and as soon as a turtle is deactivated, it no longer has access to any of the information about the inactive turtle, because it will no longer be passed to the front end.  Also, the TurtleManager must keep track of turtles that exist but are inactive so that the turtle can be reactivated.  This is an internal list of inactive turtles that cannot be updated by any other class. 
	* This design is flexible and encapsulates internal turtle list information very well.  It can be easily extended to operate similarly for other operations that can be done on an entire list of turtles or a subsection of it with actions directly on the UI that must update the backend data.

### Alternate Designs
* The original design held all the commands classes in one commands package with no superclasses.  While this definitely worked, we realized that it was important to organize our commands better so that similar commands could be grouped together.  Also, we noticed a lot of repeated code within these similar command groups, so we decided to create different packages associated with particular types of commands, and each of these packages includes a specialized superclass that contained repeated code snippets.  This was a really great idea and made refactoring much better.  
* The evolution of the Stacks class was discussed above, and that was a really important design decision that contributes to effective encapsulation and abstraction.
* The extension of multiple turtles required rethinking how a turtle is represented.  Implementing the composite design pattern helped keep much of the code in commands the same.  Discussions around this topic were about using this versus a simple TurtleManager class.  The ease and flexibility offered by the composite design pattern definitely convinced us.  Otherwise, different commands would need to take in either one turtle or multiple turtles, and this would be difficult to use Reflection on, and would not lend itself to using handy interfaces.

### Conclusions
I think that the best feature of the project's current design is the TurtleTree composite design pattern.  I'm not sure if I fully implemented it as it should be, but it was enjoyable to learn about and to see how to handle multiple objects elegantly.  I learned how valuable learning design patterns can be -- even though they might seem like cookie cutter solutions, there are certain problems that come up over and over again and applying a design pattern can be very helpful.

The worst feature is probably the communication of turtle information between the back end and front end. As mentioned in previous sections, I think this communication is a little awkward and inflexible.  I learned that it is definitely important to think more carefully about the design of passing data back and forth and to think about it earlier in the process instead of towards the end when there is less time to integrate seamlessly. 


